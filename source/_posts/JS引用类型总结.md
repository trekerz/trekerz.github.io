---
title: JS引用类型总结
subtitle: "Javascript细节"
date: 2017-10-31 21:11:46
tags: 
	- 前端基础
	- Javascript
layout: post
author: "Trekerz"
header-img: "171031.jpg"
---



## 一、Object类型

### **1. 作用特点**

(1) 存储和传输数据

### **2. 创建方式**

(1) new操作符+Object构造函数

(2) 对象字面量

此种方法可用来向函数传递可选参数（最佳实践：必需参数用命名参数，可选参数用对象字面量）。

### **3. 访问方式**

(1) 点表示法

(2) 方括号法

此种方式可通过变量来访问属性。

## 二、Array类型

### **1. 作用特点**

(1) 每一项可以保存任何类型的数值

(2) 数组的大小可以动态调整

(3) 其length属性可读可写，可以通过它增减数组末项

### **2. 创建方式**

(1) new操作符（可省略）+Array构造函数

(2) 数组字面量

### **3. 访问方式**

(1) 方括号法。

### **4. 检测数组**

(1) instanceof

(2) Array.isArray()

推荐。不管是在哪个全局执行环境中创建的。

### **5. 转换方法**  

**(1) valueOf()**

返回数组本身。

**(2) toString()**

返回每个值以逗号分隔的字符串。

**(3) toLocaleString()**

### **6. 栈方法**

**(1) push()（改变原数组）**

接受任意数量参数，逐个加到末尾，返回新数组长度。

**(2) pop()（改变原数组）**

移除最后一项，减少数组length值，返回移除的项。

### **7.队列方法**

**(1) shift()（改变原数组）**

移除第一项，减少数组length值，返回移除的项。

**(2) unshift()（改变原数组）**

在数组前端添加任意个项，返回新数组长度。

### **8. 重排序方法**

**(1) reverse()（改变原数组）**

返回翻转后的数组。

**(2) sort()（改变原数组）**

用法a：对数组中每一项调用toString()方法，获得其字符串表示，再按字符串排序；

用法b：接收1个比较函数，默认会把数组相邻项依次传入函数。

### **9.操作方法**

**(1) concat()**

创建当前数组的一个副本，然后将接收到的参数添加到副本末尾，最后返回新构建的数组（若无参数则就只复制并返回一个副本）。

**(2) slice()**

提取数组中的一或多个项组成新数组。

用法a：接收1个参数，返回参数索引到数组结尾所有项组成的数组。

用法b：接收2个参数，返回参数索引之间的项组成的数组（不包含结束位置项）。

注意：如果接收的是负数，则用数组长度加上该数。

**(3) splice()（改变原数组）**

向数组中部插入项。

用法a：删除。接收2个参数：起始位置索引、要删除的项数。返回删除的项组成的数组。

用法b：插入。接收3或3个以上参数：起始位置索引、0（要删除的项数）、要插入的项（插在起始索引前）。

用法c：替换。接收3或3个以上参数：起始位置索引、要删除的项数、要插入的项。

### **10.位置方法**

内部是利用“===”号来比较数组中的每一项。

**(1) indexOf()**

接收1或2个参数：要查找的项、查找起点索引（可选）。返回所查项第一次出现的位置索引（找不到则返回-1）。

**(2) lastIndexOf()**

从后往前找。

### **11.迭代方法**

以下五个方法都接收1或2个参数，要在每一项上运行的函数、运行该函数的作用域对象（影响this值）（可选）。函数接收三个参数：数组项的值item、该项在数组中的索引index、数组对象本身array。

**(1) every()**

若数组中每一项都返回true，则返回true。

**(2) filter()**

返回那些返回true的项所组成的数组。

**(3) forEach()**

没有返回值，只是运行函数。

**(4) map()**

返回每次函数调用结果所组成的数组。

**(5) some()**

只要数组中有一项返回true，则返回true。

### **12.归并方法**

以下两个方法都接收1或2个参数：要在每一项上调用的函数（参数为prev,cur,index,array）、作为归并基础的初始值（可选）。

第一次迭代发生在第二项；函数每次返回的值都会作为第一个参数自动传给下一项。

**(1) reduce()**

从前往后，返回一个最终归并后的值。

**(2) reduceRight()**

从后往前，返回一个最终归并后的值。

## 三、Date类型

### **1.创建方式**

**(1) new操作符+Date()构造函数**

返回的格式为”Fri June 18 2010 00:00:00 GMT+0800(中国标准时间)”。

**(2) new操作符+Date(方法parse()中的参数)**

内部会调用parse()。

**(3) new操作符+Date(方法UTC()中的参数)**

内部会调用UTC()，但日期和时间都基于本地时区。

### **2.基本方法**

**(1) Date.parse()**

接收1个表示日期的字符串。返回相应的毫秒数；若字符串格式不对则返回NaN；Opera遇到January32,2017时会倾向于把日转化为当前日，而有的会直接转化为February 1,2017。

字符串格式通常有：”6/18/2010”、”June 18,2010”、”Fri June 18 2010 00:00:00GMT+0800”（new出来返回的就是这种格式）、”2010-06-18T00:00:00”（ES5才有）。

**(2) Date.UTC()**

接收6个参数（可选）：年、月（0-11）、日（1-31）、时（0-23）、分、秒，返回相应的毫秒数。

**(3) Date.now()**

返回调用这个方法时的日期和时间的毫秒数。（可用于计算代码运行耗时）

### **3.继承的方法**

**(1) valueOf()**

返回日期的毫秒数。

**(2) toString()**

**(3) toLocaleString()**

这两者返回日期的字符串表示，返回值会因浏览器而不同。

### **4.日期格式化方法**

以下方法返回值会因浏览器而不同。

**(1) toDateString()**

星期、月、日、年。（格式特定于实现）

**(2) toTimeString()**

时、分、秒、时区。（格式特定于实现）

**(3) toLocaleDateString()**

星期、月、日、年。（格式特定于地区）

**(4) toLocaleTimeString()**

时、分、秒。（格式特定于地区）

**(5) toUTCString()**

完整的UTC日期。（格式特定于实现）

### 5.日期/时间组件方法

略（一系列的getxxx和setxxx方法）。

## 四、RegExp类型

### 1.创建方式

**(1)new操作符+RegExp(“pattern”,”flags”)**

参数是字符串，可能会需要双重转义。

**(2)对象字面量**

var expression = /pattern/flags;

其中：pattern是正则表达式，flags是行为标志（g、i、m）。正则表达式中的元字符必须转义，有( ) { } [ ] \ ^ . $ | ? * +。

ES3中两种创建方式的区别：构造函数创建的每一个实例都是一个新实例，而字面量则共享一个实例。

### 2.RegExp实例属性

RegExp的每个实例都有下列属性：

(1) **global**：布尔值，是否有g标志；

(2) **ignoreCase**：布尔值，是否有i标志；

(3) **lastIndex**：整数，下一次搜索开始索引位置；

(4) **multiline**：布尔值，是否有m标志；

(5) **source**：正则表达式的字符串表示（不带//）。

### **3.RegExp实例方法**

**(1) exec()**

接收1个参数：要应用模式的字符串。返回null或有关第一个匹配项的信息数组（一个含有index属性和input属性的Array实例，专门为捕获组而设计）。

**(2) test()**

接收1个参数：要应用模式的字符串。返回true或false。

**(3) toString()和toLocaleString()**

都返回正则表达式的字面量（带有//）。

## 五、Function类型

### **1.创建方式**

**(1) Function构造函数**，接收任意个参数（字符串），最后一个会被视为函数体。（不推荐这种，因为会被解析两次）

**(2) 函数声明**

**(3) 函数表达式**

上文中(2)和(3)的区别：函数声明会在代码执行前被解析，函数表达式只有在被执行到时才被解析。

### **2.作为值的函数**

函数名（即指针）可以作为一个值来传递，主要有下面两种用法：

**(1) 将一个函数作为另一个函数的结果返回**

**(2) 从一个函数中返回一个函数**

### **3.函数内部属性**

**(1) arguments对象**

主要用途是保存函数的参数。里面有个callee属性，指向拥有这个arguments的函数，常用于递归，但严格模式下无法访问callee。

**(2) this对象**

引用的是函数执行的环境对象，在全局作用域下执行就是window（严格模式下为undefined）。

**(3) caller属性**

保存着调用当前函数的函数的引用。严格模式下无法为caller赋值。

### **4.函数的属性和方法**

**(1) length属性**

表示函数希望接收的命名参数个数。

**(2) prototype属性**

保存所有的实例方法。

**(3) toString()（继承的）**

**(4) toLocaleString() (继承的)**

**(5) valueOf() (继承的)**

**(6) apply()**

在特定作用域中调用函数，相当于设置this对象的值。

接收2个参数：作用域、参数数组。

**(7) call()**

作用同apply()，区别在于call()接收参数是一个个列出来。

**(8) bind()**

会创建并返回一个函数实例，其this值会被绑定到传入的值。

## 六、基本包装类型

Boolean、Number、String。

每当读取一个基本类型值时，后台就会创建一个对应的基本包装类型对象实例，让我们可以调用一系列方法（这个过程发生在读取时，也就是调用方法的时候才发生，使用完后就销毁这个实例）。

### **1.创建方式**

**(1) new操作符+Number()构造函数**

注意和转型函数Number()区分。

### **2.Boolean类型**

建议永远不要使用Boolean对象。

**(1) valueOf()（重写的，返回布尔值）**

**(2) toString()（重写的）**

**(3) toLocaleString()（重写的）**

### **3.Number类型**

**(1) valueOf()（重写的，返回数值）**

**(2) toString()（重写的）**

**(3) toLocaleString()（重写的）**

**(4) toFixed()**

接收1个参数：小数位数。按照指定小数位返回数值的字符串表示。

**(5) toExponential()**

接收1个参数：小数位数。返回以指数表示的数值的字符串形式。

**(6) toPrecision()**

接收1个参数：小数位数。数值所有数字的位数（不包含指数），会根据数值自动返回最合适的形式。

### **4.String类型**

**(1) valueOf()（继承的，返回字符串）**

**(2) toString()（继承的）**

**(3) toLocaleString()（继承的）**

**(4) length属性**

注意：双字节字符也算作一个字符

**(5) charAt()**

接收1个参数：字符索引。返回单字符的字符串形式。

注意：在某些浏览器中用[]语法可以等价这个方法。

**(6) charCodeAt()**

接收1个参数：字符索引。返回单字符的字符编码。

**(7) concat()**

接收任意个参数，拼接一个或多个字符串，返回新字符串。

**(8) slice()**

接收1或2个参数：开始索引、结束索引（可选，不包含结束位置）。返回子字符串。

注意：对于负值，把负值与字符长度相加。

**(9) substring()**

接收1或2个参数：开始索引、结束索引（可选，不包含结束位置）。返回子字符串。

注意：对于负值，都转换为0。

**(10) substr()**

接收1或2个参数：开始索引、截取长度（可选）。返回子字符串。

注意：对于负值，第一个参数则与字符长度相加，第二个参数则转换为0。

**(11) indexOf()**

从一个字符串中搜索给定的子字符串，返回-1或子字符串第一次出现的位置索引。

**(12) lastIndexOf()**

从后往前。

**(13) trim()**

创建一个字符串副本，删除前置及后缀的所有空格，返回新字符串。

注意：chrome还支持trimLeft()和trimRight()

**(14) toLowerCase()**

不改变原字符串，返回的是新字符串。

**(15) toLocaleLowerCase()**

**(16) toUpperCase()**

**(17) toLocaleUpperCase()**

**(18) match()**

接收1个参数：正则表示式或RegExp对象。返回一个数组。与exec()方法正好执行和被执行对象相反。

**(19) search()**

接收1个参数：正则表示式或RegExp对象。返回-1或字符串中第一个匹配项的索引。

**(20) replace()**

接收2个参数：正则表示式或RegExp对象或一个字符串、一个字符串或一个函数。返回替换后的新字符串，但不改变原字符串。

注意：若第一个参数是字符串，则只替换一次；想替换全部只能用正则，并且加g。

注意：若第二个参数是字符串，则可以加上一些特殊的字符序列来将匹配插入结果中。

注意：若第二个参数是函数，则函数的参数为：模式的匹配项、第一捕获组的匹配项（若有）、第二捕获组的匹配项（若有）、……、模式匹配项在字符串中的位置、原始字符串。

**(21) split()**

接收1或2个参数：指定的分隔符、返回的数组的大小。返回分隔后组成的数组。

**(22) localeCompare()**

比较两个字符串，如果字符串在字母表中应该排在字符串参数之前，则返回-1，相等则返回0，应排在之后则返回1。

注意：该方法会按照地区来决定是否考虑大小写。

**(23) fromCharCode()**

接收任意个参数：字符编码。返回字符编码组成的字符串。

**(24) HTML方法**

就是用方法来创建html标签并以字符串形式返回。尽量不要使用。

## 七、单体内置对象

上面介绍的所有这些对象在程序执行前已经存在了，叫做内置对象。ECMA-262还定义了两个单体内置对象：Global和Math。

### **1.Global对象**

不属于任何其他对象的属性和方法，最终都是它的属性和方法。

所有在全局作用域中定义的属性和函数都是Global对象的属性。例如isNaN()、isFinite()、parseInt()、parseFloat()。

**(1) encodeURI()**

对URI进行编码，替换掉空格，从而让浏览器能够理解。

**(2) encodeURIComponent()**

替换掉所有非字母数字字符（包括空格）。

**(4) decodeURI()**

**(5) decodeURIComponent()**

**(6) eval()**

接收1个参数：要执行的ECMAScript字符串。

注意：被执行的代码与该执行环境有相同作用域链。

注意：严格模式下，外部访问不到eval()中创建的任何变量或函数。

**(7) Global对象的属性**

undefined、NaN、Infinity以及各种构造函数（包括上面的几个引用类型）都是Global对象的属性。

注意：Web浏览器下Global对象是window对象的一部分，所以全局作用域中声明的各种变量、函数就都成了window对象的属性。

### **2.Math对象**

**(1) Math对象的属性**

| Math.E      | Math.LN10 | Math.LN2     | Math.LOG2E |
| ----------- | --------- | ------------ | ---------- |
| Math.LOG10E | Math.PI   | Math.SQRT1_2 | Math.SQRT2 |

**(2) Math.min()、Math.max()**

接收任意个参数。

数组技巧：var values = [1,2,3,4,5,6]; var max =Math.max.apply(Math,values);

**(3) Math.ceil()**

向上舍入。

**(4) Math.floor()**

向下舍入。

**(5) Math.round()**

四舍五入。

**(6) Math.random()**

返回 **[0,1)**之间的一个随机数。

技巧：值 = Math.floor( Math.random * 可能值的总数+ 第一个可能的值 );

**(7) 其它方法**

| Math.abs(num)   | Math.exp(num) | Math.log(num) | Math.pow(num,power) |
| --------------- | ------------- | ------------- | ------------------- |
| Math.sqrt(num)  | Math.acos(x)  | Math.asin(x)  | Math.atan(x)        |
| Math.atan2(y,x) | Math.cos(x)   | Math.sin(x)   | Math.tan(x)         |

注意：在不同实现中精度可能会有不同。

<br/>