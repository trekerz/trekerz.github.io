---
title: 正则表达式深入
subtitle: "冷门知识点"
date: 2019-11-28 15:14:09
tags: 
	- 笔记
	- 读书笔记
layout: post
author: "Trekerz"
header-img: "/bing/OldTownTallinn_ZH-CN4833535739_1920x1080.jpg"
---







## 一、正则表达式引擎

说起回溯陷阱，要先从正则表达式的引擎说起。正则引擎主要可以分为基本不同的两大类：一种是**DFA（确定型有穷自动机）**，另一种是**NFA（不确定型有穷自动机）**。

简单来讲，NFA 对应的是**正则表达式主导的匹配**，而 DFA 对应的是**文本主导的匹配**。

**DFA**从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等；

**NFA**则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。

NFA支持更多的特性，因而绝大多数编程场景下（包括java，js），我们面对的是NFA。

## 二、回溯

例子1：

```javascript
const reg = /ab{1,3}c/
```

中间的b需要匹配1~3次。那么对于文本“abbbc”，按照NFA引擎的匹配规则，其实是没有发生回溯的，在表达式中的a匹配完成之后，b恰好和文本中的3个b完整匹配，之后是c发生匹配，一气呵成。如果我们把文本换成“abc”呢？无非就是少了一个字母b，却发生了所谓的回溯。

![](https://images2017.cnblogs.com/blog/926638/201708/926638-20170825103606230-2128500523.jpg)

1~2步应该都好理解，但是为什么在第3步开始，虽然已经文本中已经有一个b匹配了b{1,3}，后面还会拉着字母c跟b{1,3}做比较呢？这个就是我们下面将要提到的正则的**贪婪特性**（默认贪婪），也就是说b{1,3}会竭尽所能的匹配最多的字符。在这个地方我们先知道它一直要匹配到撞上南墙为止。 在这种情况下，第3步发生不匹配之后，整个匹配流程并没有走完，而是像栈一样，将字符c吐出来，然后去用正则表达式中的c去和文本中的c进行匹配。这样就发生了一次**回溯**。

## 三、贪婪、懒惰与独占

* `?`：告诉引擎匹配前导字符0次或一次。事实上是表示前导字符是可选的。
* `+`：告诉引擎匹配前导字符1次或多次。
* `*`：告诉引擎匹配前导字符0次或多次。
* `{min, max}`：告诉引擎匹配前导字符min次到max次。min和max都是非负整数。如果有逗号而max被省略了，则表示max没有限制；如果逗号和max都被省略了，则表示重复min次。

默认情况下，这个几个特殊字符都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。

在以上字符后加上一个**问号（？）**则可以开启**懒惰模式**，在该模式下，正则引擎**尽可能少的重复匹配字符**，匹配成功之后它会继续匹配剩余的字符串。

如果在以上四种表达式后加上一个**加号（+）**，则会开启**独占模式**。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就**会结束匹配而不会回溯**。（可以用来解决复杂正则的回溯陷阱）





参考资料：[正则表达式三种模式：贪婪模式、懒惰模式、独占模式](https://blog.csdn.net/weixin_42516949/article/details/80858913)





<br/>



<center>--end--</center>



<br/>